--shifting and rotation--    ~> / <~

--multi-triggering functions--
ply
stut, stutWith
chop
striate


Hello World, welcome to our new tutorial on Tidalcycles. 

Last time we talked about functions and learnt the basic ones: fast, slow, rev and palindrome. 
Today we are going to focus on rotation and learn some other functions.

So, what's rotation? This technique is borrowed from the tradition of classical counterpoint and it's based on the idea of shifting patterns in time.
A good example of rotation could be Clapping Music by Steve Reich, where a pattern is overlapped to the same pattern shifting at every repetition.

Let's see how to shift and rotate elements on Tidal. As usual we will start from a basic pattern. 

d1 $ s "bd cp bin bin"

Shifting is particularly effective when you have more than one pattern, so we will copy this pattern and apply the rotate function on it.

d1 $ s "bd cp bin ~"

d2 $ (0.25 ~>) $ s "bd cp bin ~" 

We shifted the second pattern of 25% to the right. The argument is a float number from 0 to 1. 
That means that the pattern is actually "~ bd cp bin". So when d1 is playing bd, d2 is on a rest, then d1 plays cp and d1 plays bd and so on.
Note that differently from other functions, such as fast and slow, the shifting function is all enclosed in round brackets, 
instead of enclosing only the argument, and that we have to write the argument BEFORE the function. 

We can also rotate to the left: 

d3 $ (0.25 <~) $ s "bd cp bin ~" 

Now d3 is playing "cp bin bin bd".
You can put a pattern instead of a number, so that the amount of shifting changes during one or more cycles.

d3 $ ("<0.25 0.5>" <~) $ s "bd cp bin ~" 

d3 shifts the pattern of 25% during a cycle, than shifts it of 50%. 
However the second shifting value is not cumulative: it is always related to the written pattern.

Until now, we shifted every element of the pattern, including rests. What if we want to preserve the structure of rests inside the pattern?
We can use the rot function:

d1 $ rot 1 $ s "bd cp bin ~"

In this way we have shifted every element to the place of the next one on the right, aside from rests. 
So now our pattern is "bin bd cp ~". 
Differently from the shift function, rot has an integer value as an argument, equal to the number of shifts to the right every element will do.

If we want to rotate left, there's the rotL function:

d1 $ rotL 1 $ s "bd cp bin ~"

Now our pattern is "cp bin bd ~"



